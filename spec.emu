<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: ECMAScript class brand check proposal
stage: -1
contributors: HE Shi-Jun, XU Tian-Yang, Tu Qiang
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <emu-clause id="sec-object-type">
      <h1>The Object Type</h1>
      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>Object Internal Methods and Internal Slots</h1>
        <p>
          <ins>
            All objects have an internal slot named [[ClassBrands]],
            which is a List of class brand.
            Initially, it is an empty List.
          </ins>
        </p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>Syntax-Directed Operations</h1>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        Static Semantics: Contains (
          _symbol_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <p>Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of Contains:</p>
      <emu-alg>
        1. For each child node _child_ of this Parse Node, do
          1. If _child_ is an instance of _symbol_, return *true*.
          1. If _child_ is an instance of a nonterminal, then
            1. Let _contained_ be the result of _child_ Contains _symbol_.
            1. If _contained_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        <del>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`

        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`

        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
        </del>
      </emu-grammar>
      <emu-alg>
        1. <del>Return *false*.</del>
      </emu-alg>
      <emu-grammar>
        <ins>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
        </ins>
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is one of |ClassHasInstanceCall|, then
          1. If |FormalParameters| Contains _symbol_ is *true*, return *true*.
          1. If |FunctionBody| Contains _symbol_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        <ins>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
        </ins>
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is one of |ClassHasInstanceCall|, then
          1. If |FormalParameters| Contains _symbol_ is *true*, return *true*.
          1. If |GeneratorBody| Contains _symbol_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        <ins>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
        </ins>
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is one of |ClassHasInstanceCall|, then
          1. If |FormalParameters| Contains _symbol_ is *true*, return *true*.
          1. If |AsyncGeneratorBody| Contains _symbol_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>
        <ins>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
        </ins>
      </emu-grammar>
      <emu-alg>
        1. If _symbol_ is one of |ClassHasInstanceCall|, then
          1. If |FormalParameters| Contains _symbol_ is *true*, return *true*.
          1. If |AsyncFunctionBody| Contains _symbol_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. <del>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super` or `this`, return *false*.</del>
        1. <ins>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, |ClassHasInstanceCall|, `super` or `this`, return *false*.</ins>
        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.
        1. Return |ConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. <del>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.</del>
        1. <ins>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, |ClassHasInstanceCall|, `super`, or `this`, return *false*.</ins>
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. <del>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.</del>
        1. <ins>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, |ClassHasInstanceCall|, `super`, or `this`, return *false*.</ins>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. If _head_ Contains _symbol_ is *true*, return *true*.
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>Miscellaneous</h1>

    <emu-clause id="sec-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>

      <emu-grammar type="definition">
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          SuperCall
          ImportCall
          CallExpression Arguments
          CallExpression TemplateLiteral
          <ins>ClassHasInstanceCall</ins>
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>
  <emu-clause id="sec-environment-records" oldids="sec-lexical-environments">
    <h1>Environment Records</h1>
    <emu-clause id="sec-the-environment-record-type-hierarchy">
      <h1>The Environment Record Type Hierarchy</h1>
      <emu-table id="table-abstract-methods-of-environment-records" caption="Abstract Methods of Environment Records" oldids="table-15">
        <table>
          <tbody>
          <tr>
            <th>
              Method
            </th>
            <th>
              Purpose
            </th>
          </tr>
          <tr>
            <td>
              HasBinding(N)
            </td>
            <td>
              Determine if an Environment Record has a binding for the String value _N_. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              CreateMutableBinding(N, D)
            </td>
            <td>
              Create a new but uninitialized mutable binding in an Environment Record. The String value _N_ is the text of the bound name. If the Boolean argument _D_ is *true* the binding may be subsequently deleted.
            </td>
          </tr>
          <tr>
            <td>
              CreateImmutableBinding(N, S)
            </td>
            <td>
              Create a new but uninitialized immutable binding in an Environment Record. The String value _N_ is the text of the bound name. If _S_ is *true* then attempts to set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding.
            </td>
          </tr>
          <tr>
            <td>
              InitializeBinding(N, V)
            </td>
            <td>
              Set the value of an already existing but uninitialized binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and is a value of any ECMAScript language type.
            </td>
          </tr>
          <tr>
            <td>
              SetMutableBinding(N, V, S)
            </td>
            <td>
              Set the value of an already existing mutable binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is *true* and the binding cannot be set throw a *TypeError* exception.
            </td>
          </tr>
          <tr>
            <td>
              GetBindingValue(N, S)
            </td>
            <td>
              Returns the value of an already existing binding from an Environment Record. The String value _N_ is the text of the bound name. _S_ is used to identify references originating in strict mode code or that otherwise require strict mode reference semantics. If _S_ is *true* and the binding does not exist throw a *ReferenceError* exception. If the binding exists but is uninitialized a *ReferenceError* is thrown, regardless of the value of _S_.
            </td>
          </tr>
          <tr>
            <td>
              DeleteBinding(N)
            </td>
            <td>
              Delete a binding from an Environment Record. The String value _N_ is the text of the bound name. If a binding for _N_ exists, remove the binding and return *true*. If the binding exists but cannot be removed return *false*. If the binding does not exist return *true*.
            </td>
          </tr>
          <tr>
            <td>
              HasThisBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `this` binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              HasSuperBinding()
            </td>
            <td>
              Determine if an Environment Record establishes a `super` method binding. Return *true* if it does and *false* if it does not.
            </td>
          </tr>
          <tr>
            <td>
              <ins>HasClassBinding()</ins>
            </td>
            <td>
              <ins>Determine if an Environment Record establishes a `class` method binding. Return *true* if it does and *false* if it does not.</ins>
            </td>
          </tr>
          <tr>
            <td>
              WithBaseObject()
            </td>
            <td>
              If this Environment Record is associated with a `with` statement, return the with object. Otherwise, return *undefined*.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-declarative-environment-records">
        <h1>Declarative Environment Records</h1>
        <emu-clause id="sec-declarative-environment-records-hassuperbinding" type="concrete method">
          <h1><ins>HasClassBinding ( )</ins></h1>
          <p>
            Regular declarative Environment Records do not provide a class binding.
          </p>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-object-environment-records">
        <h1>Object Environment Records</h1>
        <emu-clause id="sec-object-environment-records-hassuperbinding" type="concrete method">
          <h1><ins>HasClassBinding ( )</ins></h1>
          <p>
            Regular declarative Environment Records do not provide a class binding.
          </p>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-function-environment-records" oldids="function-environment">
        <h1>Function Environment Records</h1>
        <p>A <dfn>function Environment Record</dfn> is a declarative Environment Record that is used to represent the top-level scope of a function and, if the function is not an |ArrowFunction|, provides a `this` binding. If a function is not an |ArrowFunction| function and references `super`, its function Environment Record also contains the state that is used to perform `super` method invocations from within the function.<ins> If a function is not an |ArrowFunction| function and references `class`, its function Environment Record also contains the state that is used to perform `class` property acccess from within the function.</ins></p>
        <p>Function Environment Records have the additional state fields listed in <emu-xref href="#table-additional-fields-of-function-environment-records"></emu-xref>.</p>
        <emu-table id="table-additional-fields-of-function-environment-records" caption="Additional Fields of Function Environment Records" oldids="table-16">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ThisValue]]
              </td>
              <td>
                Any
              </td>
              <td>
                This is the *this* value used for this invocation of the function.
              </td>
            </tr>
            <tr>
              <td>
                [[ThisBindingStatus]]
              </td>
              <td>
                ~lexical~ | ~initialized~ | ~uninitialized~
              </td>
              <td>
                If the value is ~lexical~, this is an |ArrowFunction| and does not have a local *this* value.
              </td>
            </tr>
            <tr>
              <td>
                [[FunctionObject]]
              </td>
              <td>
                Object
              </td>
              <td>
                The function object whose invocation caused this Environment Record to be created.
              </td>
            </tr>
            <tr>
              <td>
                [[HomeObject]]
              </td>
              <td>
                Object | *undefined*
              </td>
              <td>
                If the associated function has `super` property accesses and is not an |ArrowFunction|, [[HomeObject]] is the object that the function is bound to as a method. The default value for [[HomeObject]] is *undefined*.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[InitialClassObject]]</ins>
              </td>
              <td>
                <ins>Object | *undefined*</ins>
              </td>
              <td>
                <ins>If the associated function has `class` property access and is not an |ArrowFunction|, [[InitialClassObject]] is the class constructor function object that the function was initially bound to as a method. The default value for [[InitialClassObject]] is *undefined*.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[NewTarget]]
              </td>
              <td>
                Object | *undefined*
              </td>
              <td>
                If this Environment Record was created by the [[Construct]] internal method, [[NewTarget]] is the value of the [[Construct]] _newTarget_ parameter. Otherwise, its value is *undefined*.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>Function Environment Records support all of the declarative Environment Record methods listed in <emu-xref href="#table-abstract-methods-of-environment-records"></emu-xref> and share the same specifications for all of those methods except for HasThisBinding<del> and HasSuperBinding</del><ins>, HasSuperBinding, and HasClassBinding</ins>. In addition, function Environment Records support the methods listed in <emu-xref href="#table-additional-methods-of-function-environment-records"></emu-xref>:</p>
        <emu-table id="table-additional-methods-of-function-environment-records" caption="Additional Methods of Function Environment Records" oldids="table-17">
          <table>
            <tbody>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                BindThisValue(V)
              </td>
              <td>
                Set the [[ThisValue]] and record that it has been initialized.
              </td>
            </tr>
            <tr>
              <td>
                GetThisBinding()
              </td>
              <td>
                Return the value of this Environment Record's `this` binding. Throws a *ReferenceError* if the `this` binding has not been initialized.
              </td>
            </tr>
            <tr>
              <td>
                GetSuperBase()
              </td>
              <td>
                Return the object that is the base for `super` property accesses bound in this Environment Record. The object is derived from this Environment Record's [[HomeObject]] field. The value *undefined* indicates that `super` property accesses will produce runtime errors.
              </td>
            </tr>
            <tr>
              <td>
                <ins>GetClassBinding()</ins>
              </td>
              <td>
                <ins>Return the object that is the base for `class` property accesses bound in this Environment Record. The object is derived from this Environment Record's [[InitialClassObject]] field. The value *undefined* indicates that `class` property accesses will produce runtime errors.</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
        <p>The behaviour of the additional concrete specification methods for function Environment Records is defined by the following algorithms:</p>

        <emu-clause id="sec-function-environment-records-hasclassbinding">
          <h1><ins>HasClassBinding ( )</ins></h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*.
            1. If _envRec_.[[InitialClassObject]] has the value *undefined*, return *false*; otherwise, return *true*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-getclassbinding">
          <h1><ins>GetClassBinding ( )</ins></h1>
          <emu-alg>
            1. Let _envRec_ be the function Environment Record for which the method was invoked.
            1. Let _classObject_ be _envRec_.[[InitialClassObject]].
            1. If _classObject_ has the value *undefined*, return *undefined*.
            1. Assert: Type(_classObject_) is Object.
            1. Return ? _classObject_.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-global-environment-records">
        <h1>Global Environment Records</h1>

        <emu-clause id="sec-global-environment-records-hasclassbinding">
          <h1><ins>HasClassBinding ( )</ins></h1>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>

      </emu-clause>

    </emu-clause>
    <emu-clause id="sec-environment-record-operations" oldids="sec-lexical-environment-operations">
      <h1>Environment Record Operations</h1>

      <emu-clause id="sec-newfunctionenvironment" aoid="NewFunctionEnvironment">
        <h1>NewFunctionEnvironment ( _F_, _newTarget_ )</h1>
        <p>The abstract operation NewFunctionEnvironment takes arguments _F_ and _newTarget_. It performs the following steps when called:</p>
        <emu-alg>
          1. Assert: _F_ is an ECMAScript function.
          1. Assert: Type(_newTarget_) is Undefined or Object.
          1. Let _env_ be a new function Environment Record containing no bindings.
          1. Set _env_.[[FunctionObject]] to _F_.
          1. If _F_.[[ThisMode]] is ~lexical~, set _env_.[[ThisBindingStatus]] to ~lexical~.
          1. Else, set _env_.[[ThisBindingStatus]] to ~uninitialized~.
          1. Let _home_ be _F_.[[HomeObject]].
          1. Set _env_.[[HomeObject]] to _home_.
          1. <ins>Let _classObject_ be _F_.[[InitialClassObject]].</ins>
          1. <ins>Set _env_.[[InitialClassObject]] to _classObject_.</ins>
          1. Set _env_.[[NewTarget]] to _newTarget_.
          1. Set _env_.[[OuterEnv]] to _F_.[[Environment]].
          1. Return _env_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-execution-contexts">
    <h1>Execution Contexts</h1>
    <emu-clause id="sec-getclassenvironment" aoid="GetClassEnvironment">
      <h1>GetClassEnvironment ( )</h1>
      <p>The abstract operation GetClassEnvironment takes no arguments. It finds the Function Environment Record that currently supplies the binding of the keyword `class`. It performs the following steps when called:</p>
      <emu-alg>
        1. Let _envRec_ be the GetThisEnvironment().
        1. Repeat,
          1. If _envRec_ is not a Function Environment Record, return *empty*
          1. If _envRec_.[[HasClassBinding]]() is *true*, return _envRec_.
          1. Let _envRec_ be _envRec_.[[OuterEnv]].
        1. Return *empty*.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours</h1>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript Function Objects</h1>

    <p>ECMAScript function objects encapsulate parameterized ECMAScript code closed over a lexical environment and support the dynamic evaluation of that code. An ECMAScript function object is an ordinary object and has the same internal slots and the same internal methods as other ordinary objects. The code of an ECMAScript function object may be either strict mode code (<emu-xref href="#sec-strict-mode-code"></emu-xref>) or non-strict code. An ECMAScript function object whose code is strict mode code is called a <dfn id="strict-function">strict function</dfn>. One whose code is not strict mode code is called a <dfn id="non-strict-function">non-strict function</dfn>.</p>
    <p>In addition to [[Extensible]] and [[Prototype]], ECMAScript function objects also have the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>.</p>
    <emu-table id="table-internal-slots-of-ecmascript-function-objects" caption="Internal Slots of ECMAScript Function Objects" oldids="table-27">
      <table>
        <tbody>
        <tr>
          <th>
            Internal Slot
          </th>
          <th>
            Type
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            [[Environment]]
          </td>
          <td>
            Environment Record
          </td>
          <td>
            The Environment Record that the function was closed over. Used as the outer environment when evaluating the code of the function.
          </td>
        </tr>
        <tr>
          <td>
            [[FormalParameters]]
          </td>
          <td>
            Parse Node
          </td>
          <td>
            The root parse node of the source text that defines the function's formal parameter list.
          </td>
        </tr>
        <tr>
          <td>
            [[ECMAScriptCode]]
          </td>
          <td>
            Parse Node
          </td>
          <td>
            The root parse node of the source text that defines the function's body.
          </td>
        </tr>
        <tr>
          <td>
            [[ConstructorKind]]
          </td>
          <td>
            ~base~ | ~derived~
          </td>
          <td>
            Whether or not the function is a derived class constructor.
          </td>
        </tr>
        <tr>
          <td>
            [[Realm]]
          </td>
          <td>
            Realm Record
          </td>
          <td>
            The realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.
          </td>
        </tr>
        <tr>
          <td>
            [[ScriptOrModule]]
          </td>
          <td>
            Script Record or Module Record
          </td>
          <td>
            The script or module in which the function was created.
          </td>
        </tr>
        <tr>
          <td>
            [[ThisMode]]
          </td>
          <td>
            ~lexical~ | ~strict~ | ~global~
          </td>
          <td>
            Defines how `this` references are interpreted within the formal parameters and code body of the function. ~lexical~ means that `this` refers to the *this* value of a lexically enclosing function. ~strict~ means that the *this* value is used exactly as provided by an invocation of the function. ~global~ means that a *this* value of *undefined* or *null* is interpreted as a reference to the global object, and any other *this* value is first passed to ToObject.
          </td>
        </tr>
        <tr>
          <td>
            [[Strict]]
          </td>
          <td>
            Boolean
          </td>
          <td>
            *true* if this is a strict function, *false* if this is a non-strict function.
          </td>
        </tr>
        <tr>
          <td>
            [[HomeObject]]
          </td>
          <td>
            Object
          </td>
          <td>
            If the function uses `super`, this is the object whose [[GetPrototypeOf]] provides the object where `super` property lookups begin.
          </td>
        </tr>
        <tr>
          <td>
            <ins>[[InitialClassObject]]</ins>
          </td>
          <td>
            <ins>Object | *undefined*</ins>
          </td>
          <td>
            <ins>If the function has `class` property access, this is the function object where `class` property lookups begin.</ins>
          </td>
        </tr>
        <tr>
          <td>
            [[SourceText]]
          </td>
          <td>
            sequence of Unicode code points
          </td>
          <td>
            The <emu-xref href="#sec-source-text">source text</emu-xref> that defines the function.
          </td>
        </tr>
        <tr>
          <td>
            [[IsClassConstructor]]
          </td>
          <td>
            Boolean
          </td>
          <td>
            Indicates whether the function is a class constructor. (If *true*, invoking the function's [[Call]] will immediately throw a *TypeError* exception.)
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        )
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>an ECMAScript function object _F_</dd>
      </dl>
      <emu-alg>
        1. Let _callerContext_ be the running execution context.
        1. Let _kind_ be _F_.[[ConstructorKind]].
        1. If _kind_ is ~base~, then
          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*).
        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).
        1. Assert: _calleeContext_ is now the running execution context.
        1. If _kind_ is ~base~, then
          1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
          1. Let _initializeResult_ be InitializeInstanceElements(_thisArgument_, _F_).
          1. If _initializeResult_ is an abrupt completion, then
            1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
            1. Return Completion(_initializeResult_).
        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.
        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
        1. If _result_.[[Type]] is ~return~, then
          1. <ins>If _F_.[[Brand]] is not ~empty~:</ins>
            1. <ins>Let _currentThis_ be _constructor_.GetThisBinding()</ins>
            1. <ins>If _currentThis_.[[Type]] is not ~throw~, then append _F_.[[Brand]] to _currentThis_.[[Value]].</ins>
          1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).
          1. If _kind_ is ~base~, return NormalCompletion(_thisArgument_).
          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.
        1. Else, ReturnIfAbrupt(_result_).
        1. <ins>Let _currentThis_ be ? _constructorEnv_.GetThisBinding().</ins>
        1. <ins>If _F_.[[Brand]] is not ~empty~, then append _F_.[[Brand]] to _currentThis_.[[ClassBrands]]</ins>
        1. <del>Return ? _constructorEnv_.GetThisBinding().</del>
        1. <ins>Return _currentThis_.</ins>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-ordinaryfunctioncreate" aoid="OrdinaryFunctionCreate" oldids="sec-functionallocate,sec-functioninitialize,sec-functioncreate,sec-generatorfunctioncreate,sec-asyncgeneratorfunctioncreate,sec-async-functions-abstract-operations-async-function-create">
      <h1>OrdinaryFunctionCreate ( _functionPrototype_, _sourceText_, _ParameterList_, _Body_, _thisMode_, _Scope_ )</h1>
      <p>The abstract operation OrdinaryFunctionCreate takes arguments _functionPrototype_ (an Object), _sourceText_ (a sequence of Unicode code points), _ParameterList_ (a Parse Node), _Body_ (a Parse Node), _thisMode_ (either ~lexical-this~ or ~non-lexical-this~), and _Scope_ (an Environment Record). _sourceText_ is the source text of the syntactic definition of the function to be created. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: Type(_functionPrototype_) is Object.
        1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>.
        1. Let _F_ be ! OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_).
        1. Set _F_.[[Call]] to the definition specified in <emu-xref href="#sec-ecmascript-function-objects-call-thisargument-argumentslist"></emu-xref>.
        1. Set _F_.[[SourceText]] to _sourceText_.
        1. Set _F_.[[FormalParameters]] to _ParameterList_.
        1. Set _F_.[[ECMAScriptCode]] to _Body_.
        1. If the source text matching _Body_ is strict mode code, let _Strict_ be *true*; else let _Strict_ be *false*.
        1. Set _F_.[[Strict]] to _Strict_.
        1. If _thisMode_ is ~lexical-this~, set _F_.[[ThisMode]] to ~lexical~.
        1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.
        1. Else, set _F_.[[ThisMode]] to ~global~.
        1. Set _F_.[[IsClassConstructor]] to *false*.
        1. Set _F_.[[Environment]] to _Scope_.
        1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().
        1. Set _F_.[[Realm]] to the current Realm Record.
        1. Set _F_.[[HomeObject]] to *undefined*.
        1. <ins>Set _F_.[[InitialClassObject]] to *undefined*.</ins>
        1. Let _len_ be the ExpectedArgumentCount of _ParameterList_.
        1. Perform ! SetFunctionLength(_F_, _len_).
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-makemethod" aoid="MakeMethod">
      <h1>MakeMethod ( _F_, _homeObject_<ins>, _classObject_</ins> )</h1>
      <p>The abstract operation MakeMethod takes arguments _F_<del> and _homeObject_</del><ins>, _homeObject_, and _classObject_</ins>. It configures _F_ as a method. It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: _F_ is an ECMAScript function object.
        1. Assert: Type(_homeObject_) is Object.
        1. Assert: Type(_classObject_) is either Object or Undefined.
        1. Set _F_.[[HomeObject]] to _homeObject_.
        1. <ins>Set _F_.[[InitialClassObject]] to _classObject_.</ins>
        1. Return NormalCompletion(*undefined*).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-primary-expression">
    <h1>Primary Expression</h1>
    <emu-clause id="sec-object-initializer">
      <h1>Object Initializer</h1>

      <emu-clause id="sec-runtime-semantics-propertydefinitionevaluation" oldids="sec-object-initializer-runtime-semantics-propertydefinitionevaluation" type="sdo" aoid="PropertyDefinitionEvaluation">
        <h1>Runtime Semantics: PropertyDefinitionEvaluation</h1>
        <p>With parameters _object_<del> and _enumerable_</del><ins>, _enumerable_ and optional parameter _classObject_</ins>.</p>
        <emu-grammar>PropertyDefinitionList : PropertyDefinitionList `,` PropertyDefinition</emu-grammar>
        <emu-alg>
          1. <ins>Assert: _classObject_ is not present or Type(_classObject_) is Undefined.</ins>
          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with arguments _object_ and _enumerable_.
          1. Return the result of performing PropertyDefinitionEvaluation of |PropertyDefinition| with arguments _object_ and _enumerable_.
        </emu-alg>
        <emu-grammar>PropertyDefinition : `...` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. <ins>Assert: _classObject_ is not present or Type(_classObject_) is Undefined.</ins>
          1. Let _exprValue_ be the result of evaluating |AssignmentExpression|.
          1. Let _fromValue_ be ? GetValue(_exprValue_).
          1. Let _excludedNames_ be a new empty List.
          1. Return ? CopyDataProperties(_object_, _fromValue_, _excludedNames_).
        </emu-alg>
        <emu-grammar>PropertyDefinition : IdentifierReference</emu-grammar>
        <emu-alg>
          1. <ins>Assert: _classObject_ is not present or Type(_classObject_) is Undefined.</ins>
          1. Let _propName_ be StringValue of |IdentifierReference|.
          1. Let _exprValue_ be the result of evaluating |IdentifierReference|.
          1. Let _propValue_ be ? GetValue(_exprValue_).
          1. Assert: _enumerable_ is *true*.
          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
          1. Return ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_).
        </emu-alg>
        <emu-grammar>PropertyDefinition : PropertyName `:` AssignmentExpression</emu-grammar>
        <emu-alg>
          1. <ins>Assert: _classObject_ is not present or Type(_classObject_) is Undefined.</ins>
          1. Let _propKey_ be the result of evaluating |PropertyName|.
          1. ReturnIfAbrupt(_propKey_).
          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then
            1. Let _propValue_ be ? NamedEvaluation of |AssignmentExpression| with argument _propKey_.
          1. Else,
            1. Let _exprValueRef_ be the result of evaluating |AssignmentExpression|.
            1. Let _propValue_ be ? GetValue(_exprValueRef_).
          1. Assert: _enumerable_ is *true*.
          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.
          1. Return ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).
        </emu-alg>
        <emu-note>
          <p>An alternative semantics for this production is given in <emu-xref href="#sec-__proto__-property-names-in-object-initializers"></emu-xref>.</p>
        </emu-note>
        <emu-grammar>
          MethodDefinition :
            PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
            `get` PropertyName `(` `)` `{` FunctionBody `}`
            `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`
        </emu-grammar>
        <emu-alg>
          1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_<del> and _enumerable_</del><ins>, _enumerable_ and _classObject_</ins>.
        </emu-alg>
        <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
        <emu-alg>
          1. Return ? MethodDefinitionEvaluation of |GeneratorMethod| with arguments _object_<del> and _enumerable_</del><ins>, _enumerable_ and _classObject_</ins>.
        </emu-alg>
        <emu-grammar>
          AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
        </emu-grammar>
        <emu-alg>
          1. Return ? MethodDefinitionEvaluation of |AsyncGeneratorMethod| with arguments _object_<del> and _enumerable_</del><ins>, _enumerable_ and _classObject_</ins>.
        </emu-alg>
        <emu-grammar>
          AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
        </emu-grammar>
        <emu-alg>
          1. Return ? MethodDefinitionEvaluation of |AsyncMethod| with arguments _object_<del> and _enumerable_</del><ins>, _enumerable_ and _classObject_</ins>.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        <ins>ClassHasInstanceCall[?Yield, ?Await]</ins>
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      <ins>ClassHasInstanceCall[Yield, Await] :</ins>
        `class` `.` `hasInstance` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
    </emu-grammar>

    <emu-clause id="sec-class-keyword">
      <h1>The `class` Keyword</h1>
      <emu-clause id="sec-class-keyword-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evalutaion</h1>
        <emu-grammar>
          ClassHasInstanceCall :
            `class` `.` `hasInstance` `(` AssignmentExpression `,`? `)`
        </emu-grammar>
        <emu-alg>
          1. Let _inst_ be the result of |AssignmentExpression|.
          1. If Type(_inst_) is not Object.
            1. Return *false*.
          1. Let _envRec_ be GetClassEnvironment()
          1. If _envRec_ is ~empty~, return *false*.
          1. Let _F_ be _envRec_.[[GetClassBinding]]().
          1. If _F_.[[Brand]] is ~empty~, return *false*.
          1. If _inst_.[[ClassBrands]] includes _F_.[[Brand]], then
            1. Return *true*.
          1. Else,
            1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>

  <emu-clause id="sec-function-definitions">
    <h1>Function Definitions</h1>
    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.
        </li>
        <li>
          <ins>It is a Syntax Error if |FormalParameters| Contains |ClassHasInstanceCall| is *true*.</ins>
        </li>
        <li>
          <ins>It is a Syntax Error if |FunctionBody| Contains |ClassHasInstanceCall| is *true*.</ins>
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-method-definitions">
    <h1>Method Definitions</h1>
    <emu-clause id="sec-runtime-semantics-definemethod">
      <h1>Runtime Semantics: DefineMethod</h1>
      <p>With parameter _object_ and optional <del>parameter _functionPrototype_</del><ins>parameters _functionPrototype_ and _classObject_</ins>.</p>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. If _functionPrototype_ is present, then
          1. Let _prototype_ be _functionPrototype_.
        1. Else,
          1. Let _prototype_ be %Function.prototype%.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _scope_).
        1. Perform MakeMethod(_closure_, _object_<ins>, _classObject_</ins>).
        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-methoddefinitionevaluation" oldids="sec-method-definitions-runtime-semantics-propertydefinitionevaluation,sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation,sec-asyncgenerator-definitions-propertydefinitionevaluation,sec-async-function-definitions-PropertyDefinitionEvaluation" type="sdo" aoid="MethodDefinitionEvaluation">
      <h1>Runtime Semantics: MethodDefinitionEvaluation</h1>
      <p>With parameters _object_<del> and _enumerable_</del><ins>, _enumerable_ and optional parameter _classObject_</ins>.</p>
      <emu-grammar>MethodDefinition : PropertyName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _methodDef_ be ? DefineMethod of |MethodDefinition| with <del>argument _object_</del><ins>arguments _object_, *undefined* and _classObject_</ins>.
        1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).
        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _methodDef_.[[Closure]], [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _methodDef_.[[Key]], _desc_).
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` PropertyName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _scope_).
        1. Perform MakeMethod(_closure_, _object_<ins>, _classObject_</ins>).
        1. Perform SetFunctionName(_closure_, _propKey_, *"get"*).
        1. Let _desc_ be the PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _scope_).
        1. Perform MakeMethod(_closure_, _object_<ins>, _classObject_</ins>).
        1. Perform SetFunctionName(_closure_, _propKey_, *"set"*).
        1. Let _desc_ be the PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` PropertyName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _sourceText_ be the source text matched by |GeneratorMethod|.
        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _scope_).
        1. Perform MakeMethod(_closure_, _object_<ins>, _classObject_</ins>).
        1. Perform SetFunctionName(_closure_, _propKey_).
        1. Let _prototype_ be ! OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).
        1. Perform DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
      <emu-grammar>
        AsyncGeneratorMethod : `async` `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. Let _scope_ be the running execution context's LexicalEnvironment.
        1. Let _sourceText_ be the source text matched by |AsyncGeneratorMethod|.
        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _scope_).
        1. Perform ! MakeMethod(_closure_, _object_<ins>, _classObject_</ins>).
        1. Perform ! SetFunctionName(_closure_, _propKey_).
        1. Let _prototype_ be ! OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).
        1. Perform ! DefinePropertyOrThrow(_closure_, *"prototype"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).
        1. Let _desc_ be PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. Let _propKey_ be the result of evaluating |PropertyName|.
        1. ReturnIfAbrupt(_propKey_).
        1. Let _scope_ be the LexicalEnvironment of the running execution context.
        1. Let _sourceText_ be the source text matched by |AsyncMethod|.
        1. Let _closure_ be ! OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _scope_).
        1. Perform ! MakeMethod(_closure_, _object_<ins>, _classObject_</ins>).
        1. Perform ! SetFunctionName(_closure_, _propKey_).
        1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.
        1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
      </emu-alg>
    </emu-clause>

  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>
          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.
        </li>
        <li>
          <ins>It is a Syntax Error if |FormalParameters| Contains |ClassHasInstanceCall| is *true*.</ins>
        </li>
        <li>
          <ins>It is a Syntax Error if |GeneratorBody| Contains |ClassHasInstanceCall| is *true*.</ins>
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>
    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.</li>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>
        <li><ins>It is a Syntax Error if |FormalParameters| Contains |ClassHasInstanceCall| is *true*.</ins></li>
        <li><ins>It is a Syntax Error if |AsyncGeneratorBody| Contains |ClassHasInstanceCall| is *true*.</ins></li>
      </ul>
    </emu-clause>

  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>

    <p>
      <ins>
        All class objects have an internal slot [[Brand]].
        Which is a unique value across realm represent for class brand.
      </ins>
    </p>

    <emu-clause id="sec-static-semantics-includeclasshasinstance" type="sdo" aoid="IncludeClassHasInstance">
      <h1><ins>Static Semantics: IncludeClassHasInstance</ins></h1>
      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. Return IncludeClassHasInstance of |MethodDefinition|.
      </emu-alg>
      <emu-grammar>
        ClassElement:
          FieldDefinition
          `static` FieldDefinition
      </emu-grammar>
      <emu-alg>
        1. Return IncludeClassHasInstance of |FieldDefintion|.
      </emu-alg>
      <emu-grammar>
        MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        2. Return |FunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return |FunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |PropertySetParameterList| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |GeneratorBody| Contains |ClassHasInstanceCall|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |AsyncGeneratorBody| Contains |ClassHasInstanceCall|.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |ClassHasInstanceCall| is *true*, return *true*.
        1. Return |AsyncFunctionBody| Contains |ClassHasInstanceCall|.
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. If |Initializer_opt| is not preset, return *false*.
        1. Return IncludeClassHasInstance of |Initializer|.
      </emu-alg>
      <emu-grammar>
        Initializer :
          `=` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return |AssignmentExpression| Contains |ClassHasInstanceCall|
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
      <p>With parameters _classBinding_ and _className_.</p>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _classScope_ be NewDeclarativeEnvironment(_env_).
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScope_.CreateImmutableBinding(_classBinding_, *true*).
        1. If |ClassHeritage_opt| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classScope_.
          1. Let _superclassRef_ be the result of evaluating |ClassHeritage|.
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(_superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be ! OrdinaryObjectCreate(_protoParent_).
        1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. If _constructor_ is ~empty~, then
          1. Let _steps_ be the algorithm steps defined in <emu-xref href="#sec-default-constructor-functions" title></emu-xref>.
          1. Let _F_ be ! CreateBuiltinFunction(_steps_, 0, _className_, &laquo; [[ConstructorKind]], [[SourceText]] &raquo;, ~empty~, _constructorParent_).
        1. Else,
          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.
          1. Let _F_ be _constructorInfo_.[[Closure]].
          1. Perform ! MakeClassConstructor(_F_).
          1. Perform ! SetFunctionName(_F_, _className_).
        1. <ins>Set _F_.[[InitialClassObject]] to _F_.</ins>
        1. Perform ! MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage_opt| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Perform ! CreateMethodProperty(_proto_, *"constructor"*, _F_).
        1. If |ClassBody_opt| is not present, let _methods_ be a new empty List.
        1. Else, let _methods_ be NonConstructorMethodDefinitions of |ClassBody|.
        1. <ins>Let _hasBrandCheck_ be *false*.</ins>
        1. For each |ClassElement| _m_ of _methods_, do
          1. <ins>If IncludeClassHasInstance of _e_ is *true*, Set _hasBrandCheck_ to *true*.</ins>
          1. If IsStatic of _m_ is *false*, then
            1. Let _status_ be PropertyDefinitionEvaluation of _m_ with arguments _proto_<del> and *false*</del><ins>, *false* and _F_</ins>.
          1. Else,
            1. Let _status_ be PropertyDefinitionEvaluation of _m_ with arguments _F_<del> and *false*</del><ins>, *false* and _F_</ins>.
          1. If _status_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Return Completion(_status_).
        1. <ins>If _hasBrandCheck_ is *true*, then</ins>
          1. <ins>Set _F_.[[Brand]] to a new unique value.</ins>
        1. <ins>Else</ins>
          1. <ins>Set _F_.[[Brand]] to ~empty~.</ins>
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScope_.InitializeBinding(_classBinding_, _F_).
        1. Return _F_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-function-definitions">
    <h1>Async Function Definitions</h1>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>
        <li><ins>It is a Syntax Error if |FormalParameters| Contains |ClassHasInstanceCall| is *true*.</ins></li>
        <li><ins>It is a Syntax Error if |AsyncFunctionBody| Contains |ClassHasInstanceCall| is *true*.</ins></li>
      </ul>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>
  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>
    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>

      <emu-grammar>ScriptBody : StatementList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |StatementList| Contains `super` unless the source code containing `super` is eval code that is being processed by a direct eval. Additional early error rules for `super` within direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if |StatementList| Contains |NewTarget| unless the source code containing |NewTarget| is eval code that is being processed by a direct eval. Additional early error rules for |NewTarget| in direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
          </li>
          <li>
            <ins>It is a Syntax Error if |StatementList| Contains |ClassHasInstanceCall|.</ins>
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |StatementList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |StatementList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |StatementList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |StatementList| with argument &laquo; &raquo; is *false* unless the source code containing |ScriptBody| is eval code that is being processed by a direct eval.
          </li>
        </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>
    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>
      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the LexicallyDeclaredNames of |ModuleItemList| also occurs in the VarDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if the ExportedNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the ExportedBindings of |ModuleItemList| does not also occur in either the VarDeclaredNames of |ModuleItemList|, or the LexicallyDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains `super`.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains |NewTarget|.
          </li>
          <li>
            <ins>It is a Syntax Error if |ModuleItemList| Contains |ClassHasInstanceCall|.</ins>
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |ModuleItemList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |ModuleItemList| with argument &laquo; &raquo; is *false*.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
