<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Proposal Title Goes Here
stage: -1
contributors: Your Name(s) Here
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript Data Types and Values</h1>
  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>
    <emu-clause id="sec-object-type">
      <h1>The Object Type</h1>
      <emu-clause id="sec-object-internal-methods-and-internal-slots">
        <h1>Object Internal Methods and Internal Slots</h1>
        <p>
          <ins>
            All objects have an internal slot named [[Brands]],
            which is a List of class brand.
            Initially, it is an empty List.
          </ins>
        </p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-syntax-directed-operations">
  <h1>Syntax-Directed Operations</h1>

  <emu-clause id="sec-syntax-directed-operations-contains">
    <h1>Contains</h1>

    <emu-clause id="sec-static-semantics-contains" oldids="sec-object-initializer-static-semantics-contains,sec-static-semantics-static-semantics-contains,sec-function-definitions-static-semantics-contains,sec-arrow-function-definitions-static-semantics-contains,sec-generator-function-definitions-static-semantics-contains,sec-async-generator-function-definitions-static-semantics-contains,sec-class-definitions-static-semantics-contains,sec-async-function-definitions-static-semantics-Contains,sec-async-arrow-function-definitions-static-semantics-Contains" type="sdo">
      <h1>
        Static Semantics: Contains (
          _symbol_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <p>Every grammar production alternative in this specification which is not listed below implicitly has the following default definition of Contains:</p>
      <emu-alg>
        1. For each child node _child_ of this Parse Node, do
          1. If _child_ is an instance of _symbol_, return *true*.
          1. If _child_ is an instance of a nonterminal, then
            1. Let _contained_ be the result of _child_ Contains _symbol_.
            1. If _contained_ is *true*, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
      <emu-alg>
        1. <del>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super` or `this`, return *false*.</del>
        1. <ins>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, |BrandCheckCall|, `super` or `this`, return *false*.</ins>
        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.
        1. Return |ConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : `async` AsyncArrowBindingIdentifier `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. <del>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.</del>
        1. <ins>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, |BrandCheckCall|, `super`, or `this`, return *false*.</ins>
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
      <emu-grammar>
        AsyncArrowFunction : CoverCallExpressionAndAsyncArrowHead `=>` AsyncConciseBody
      </emu-grammar>
      <emu-alg>
        1. <del>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.</del>
        1. <ins>If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, |BrandCheckCall|, `super`, or `this`, return *false*.</ins>
        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.
        1. If _head_ Contains _symbol_ is *true*, return *true*.
        1. Return |AsyncConciseBody| Contains _symbol_.
      </emu-alg>
    </emu-clause>

  <emu-clause id="sec-syntax-directed-operations-miscellaneous">
    <h1>Miscellaneous</h1>

    <emu-clause id="sec-static-semantics-assignmenttargettype">
      <h1>Static Semantics: AssignmentTargetType</h1>

      <emu-grammar type="definition">
        CallExpression :
          CoverCallExpressionAndAsyncArrowHead
          SuperCall
          ImportCall
          CallExpression Arguments
          CallExpression TemplateLiteral
          <ins>BrandCheckCall</ins>
      </emu-grammar>
      <emu-alg>
        1. Return ~invalid~.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ordinary-and-exotic-objects-behaviours">
  <h1>Ordinary and Exotic Objects Behaviours</h1>

  <emu-clause id="sec-ecmascript-function-objects">
    <h1>ECMAScript Function Objects</h1>

    <emu-clause id="sec-ecmascript-function-objects-construct-argumentslist-newtarget" type="internal method">
      <h1>
        [[Construct]] (
          _argumentsList_: a List of ECMAScript language values,
          _newTarget_: a constructor,
        )
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>an ECMAScript function object _F_</dd>
      </dl>
      <emu-alg>
        1. Let _callerContext_ be the running execution context.
        1. Let _kind_ be _F_.[[ConstructorKind]].
        1. If _kind_ is ~base~, then
          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Object.prototype%"*).
        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).
        1. Assert: _calleeContext_ is now the running execution context.
        1. If _kind_ is ~base~, then
          1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).
          1. Let _initializeResult_ be InitializeInstanceElements(_thisArgument_, _F_).
          1. If _initializeResult_ is an abrupt completion, then
            1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
            1. Return Completion(_initializeResult_).
        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.
        1. Let _result_ be OrdinaryCallEvaluateBody(_F_, _argumentsList_).
        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
        1. If _result_.[[Type]] is ~return~, then
          1. <ins>If _F_.[[Brand]] is not ~empty~:</ins>
            1. <ins>Let _currentThis_ be _constructor_.GetThisBinding()</ins>
            1. <ins>If _currentThis_.[[Type]] is not ~throw~, then append _F_.[[Brand]] to _currentThis_.[[Value]].</ins>
          1. If Type(_result_.[[Value]]) is Object, return NormalCompletion(_result_.[[Value]]).
          1. If _kind_ is ~base~, return NormalCompletion(_thisArgument_).
          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.
        1. Else, ReturnIfAbrupt(_result_).
        1. <ins>Let _currentThis_ be ? _constructorEnv_.GetThisBinding().</ins>
        1. <ins>If _F_.[[Brand]] is not ~empty~, then append _F_.[[Brand]] to _currentThis_.[[Brands]]</ins>
        1. <del>Return ? _constructorEnv_.GetThisBinding().</del>
        1. <ins>Return _currentThis_.</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      CallExpression[Yield, Await] :
        CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] #callcover
        SuperCall[?Yield, ?Await]
        ImportCall[?Yield, ?Await]
        <ins>BrandCheckCall[?Yield, ?Await]</ins>
        CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
        CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
        CallExpression[?Yield, ?Await] `.` IdentifierName
        CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
        CallExpression[?Yield, ?Await] `.` PrivateIdentifier

      <ins>BrandCheckCall[Yield, Await] :</ins>
        `class` `.` `hasInstance` `(` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`
    </emu-grammar>

    <emu-clause id="sec-class-keyword">
      <h1>The `class` Keyword</h1>
      <emu-clause id="sec-class-keyword-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evalutaion</h1>
        <emu-grammar>
          BrandCheckCall :
            `class` `.` `hasInstance` `(` AssignmentExpression `,`? `)`
        </emu-grammar>
        <emu-alg>
          1. Let _inst_ be the result of |AssignmentExpression|.
          1. If Type(_inst_) is not Object.
            1. Return *false*.
          1. Let _F_ be GetConstructor().
          1. If _F_.[[Brand]] is ~empty~, Return *false*.
          1. If _inst_.[[Brands]] includes _F_.[[Brand]], then
            1. Return *true*.
          1. Else,
            1. Return *false*.
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-get-constructor" type="abstract operation">
        <h1>GetConstructor ( )</h1>
        <emu-alg>
          1. Let _envRec_ be GetThisEnvironment().
          1. Assert: _envRec_ is a function Environment Record.
          1. Let _activeFunction_ be _envRec_.[[FunctionObject]].
          1. Assert: _activeFunction_ is an ECMAScript function object.
          1. Return _activeFunction_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>
  <emu-clause id="sec-function-definitions">
    <h1>Function Definitions</h1>
    <emu-clause id="sec-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        FunctionDeclaration :
          `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`
          `function` `(` FormalParameters `)` `{` FunctionBody `}`

        FunctionExpression :
          `function` BindingIdentifier? `(` FormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <ul>
        <li>
          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |FunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |FunctionBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FunctionBody| Contains |SuperCall| is *true*.
        </li>
        <li>
          <ins>It is a Syntax Error if |FormalParameters| Contains |BrandCheckCall| is *true*.</ins>
        </li>
        <li>
          <ins>It is a Syntax Error if |FunctionBody| Contains |BrandCheckCall| is *true*.</ins>
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-arrow-function-definitions">
    <h1>Arrow Function Definitions</h1>

    <emu-clause id="sec-async-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncFunctionDeclaration :
          `async` `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
          `async` `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`

        AsyncFunctionExpression :
          `async` `function` BindingIdentifier? `(` FormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <ul>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncFunctionBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncFunctionBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncFunctionBody| Contains |SuperCall| is *true*.</li>
        <li><ins>It is a Syntax Error if |FormalParameters| Contains |BrandCheckCall| is *true*.</ins></li>
        <li><ins>It is a Syntax Error if |AsyncFunctionBody| Contains |BrandCheckCall| is *true*.</ins></li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>

    <emu-clause id="sec-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        GeneratorDeclaration :
          `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`
          `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`

        GeneratorExpression :
          `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` GeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>
          If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.
        </li>
        <li>
          If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.
        </li>
        <li>
          It is a Syntax Error if FunctionBodyContainsUseStrict of |GeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.
        </li>
        <li>
          It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |GeneratorBody|.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperProperty| is *true*.
        </li>
        <li>
          It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.
        </li>
        <li>
          It is a Syntax Error if |GeneratorBody| Contains |SuperCall| is *true*.
        </li>
        <li>
          <ins>It is a Syntax Error if |FormalParameters| Contains |BrandCheckCall| is *true*.</ins>
        </li>
        <li>
          <ins>It is a Syntax Error if |GeneratorBody| Contains |BrandCheckCall| is *true*.</ins>
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>
    <emu-clause id="sec-async-generator-function-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>
        AsyncGeneratorDeclaration :
          `async` `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
          `async` `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`

        AsyncGeneratorExpression :
          `async` `function` `*` BindingIdentifier? `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
      </emu-grammar>
      <ul>
        <li>If the source code matching |FormalParameters| is strict mode code, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied.</li>
        <li>If |BindingIdentifier| is present and the source code matching |BindingIdentifier| is strict mode code, it is a Syntax Error if the StringValue of |BindingIdentifier| is *"eval"* or *"arguments"*.</li>
        <li>It is a Syntax Error if FunctionBodyContainsUseStrict of |AsyncGeneratorBody| is *true* and IsSimpleParameterList of |FormalParameters| is *false*.</li>
        <li>It is a Syntax Error if any element of the BoundNames of |FormalParameters| also occurs in the LexicallyDeclaredNames of |AsyncGeneratorBody|.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |YieldExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |AwaitExpression| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperProperty| is *true*.</li>
        <li>It is a Syntax Error if |FormalParameters| Contains |SuperCall| is *true*.</li>
        <li>It is a Syntax Error if |AsyncGeneratorBody| Contains |SuperCall| is *true*.</li>
        <li><ins>It is a Syntax Error if |FormalParameters| Contains |BrandCheckCall| is *true*.</ins></li>
        <li><ins>It is a Syntax Error if |AsyncGeneratorBody| Contains |BrandCheckCall| is *true*.</ins></li>
      </ul>
    </emu-clause>

  </emu-clause>

  <emu-clause id="sec-class-definitions">
    <h1>Class Definitions</h1>
    <emu-clause id="sec-semantics-containsclassbrandcheck">
      <h1><ins>Static Semantics: ContainsClassBrandCheck</ins></h1>
      <emu-grammar>
        ClassElement :
          MethodDefinition
          `static` MethodDefinition
      </emu-grammar>
      <emu-alg>
        1. Return ContainsClassBrandCheck of |MethodDefinition|.
      </emu-alg>
      <emu-grammar>
        ClassElement:
          FieldDefinition
          `static` FieldDefinition
      </emu-grammar>
      <emu-alg>
        1. Return ContainsClassBrandCheck of |FieldDefintion|.
      </emu-alg>
      <emu-grammar>
        MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |BrandCheckCall| is *true*, return *true*.
        2. Return |FunctionBody| Contains |BrandCheckCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `get` ClassElementName `(` `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Return |FunctionBody| Contains |BrandCheckCall|.
      </emu-alg>
      <emu-grammar>MethodDefinition : `set` ClassElementName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. If |PropertySetParameterList| Contains |BrandCheckCall| is *true*, return *true*.
        1. Return |FunctionBody| Contains |BrandCheckCall|.
      </emu-alg>
      <emu-grammar>GeneratorMethod : `*` ClassElementName `(` UniqueFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |BrandCheckCall| is *true*, return *true*.
        1. Return |GeneratorBody| Contains |BrandCheckCall|.
      </emu-alg>
      <emu-grammar>AsyncGeneratorMethod : `async` `*` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`</emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |BrandCheckCall| is *true*, return *true*.
        1. Return |AsyncGeneratorBody| Contains |BrandCheckCall|.
      </emu-alg>
      <emu-grammar>
        AsyncMethod : `async` ClassElementName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
      </emu-grammar>
      <emu-alg>
        1. If |UniqueFormalParameters| Contains |BrandCheckCall| is *true*, return *true*.
        1. Return |AsyncFunctionBody| Contains |BrandCheckCall|.
      </emu-alg>
      <emu-grammar>
        FieldDefinition : ClassElementName Initializer?
      </emu-grammar>
      <emu-alg>
        1. If |Initializer_opt| is not preset, return *false*.
        1. Return ContainsClassBrandCheck of |Initializer|.
      </emu-alg>
      <emu-grammar>
        Initializer :
          `=` AssignmentExpression
      </emu-grammar>
      <emu-alg>
        1. Return |AssignmentExpression| Contains |BrandCheckCall|
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-classdefinitionevaluation" oldids="sec-default-constructor-functions" type="sdo">
      <h1>
        Runtime Semantics: ClassDefinitionEvaluation (
          _classBinding_: unknown,
          _className_: unknown,
        )
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _classScope_ be NewDeclarativeEnvironment(_env_).
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScope_.CreateImmutableBinding(_classBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |ClassBody_opt| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody_opt|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name whose [[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] value is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage_opt| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _classScope_.
          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.
          1. Let _superclassRef_ be the result of evaluating |ClassHeritage|.
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(_superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be ! OrdinaryObjectCreate(_protoParent_).
        1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If _constructor_ is ~empty~, then
          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:
            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
            1. If NewTarget is *undefined*, throw a *TypeError* exception.
            1. Let _F_ be the active function object.
            1. If _F_.[[ConstructorKind]] is ~derived~, then
              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.
              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().
              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).
            1. Else,
              1. NOTE: This branch behaves similarly to `constructor() {}`.
              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*).
            1. Perform ? InitializeInstanceElements(_result_, _F_).
            1. Return _result_.
          1. Let _F_ be ! CreateBuiltinFunction(_defaultConstructor_, 0, _className_, &laquo; [[ConstructorKind]], [[SourceText]] &raquo;, the current Realm Record, _constructorParent_).
        1. Else,
          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.
          1. Let _F_ be _constructorInfo_.[[Closure]].
          1. Perform ! MakeClassConstructor(_F_).
          1. Perform ! SetFunctionName(_F_, _className_).
        1. Perform ! MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage_opt| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Perform ! CreateMethodProperty(_proto_, *"constructor"*, _F_).
        1. If |ClassBody_opt| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.
        1. Let _instancePrivateMethods_ be a new empty List.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. <ins>Let _hasBrandCheck_ be *false*.</ins>
        1. For each |ClassElement| _e_ of _elements_, do
          1. <ins>If ContainsClassBrandCheck of _e_ is *true*, then</ins>
            1. <ins>Set _hasBrandCheck_ to *true*.</ins>
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be ClassElementEvaluation of _e_ with argument _proto_.
          1. Else,
            1. Let _element_ be ClassElementEvaluation of _e_ with argument _F_.
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return Completion(_element_).
          1. Set _element_ to _element_.[[Value]].
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.
            1. Else, let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement whose [[Key]] is _element_.[[Key]], then
              1. Let _existing_ be that PrivateElement.
              1. Assert: _element_.[[Kind]] and _existing_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _existing_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _existing_.[[Set]] }.
              1. Replace _existing_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _classBinding_ is not *undefined*, then
          1. Perform _classScope_.InitializeBinding(_classBinding_, _F_).
        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. <ins>If _hasBrandCheck_ is *true*, then</ins>
          1. <ins>Set _F_.[[Brand]] to a new unique value.</ins>
        1. <ins>Else</ins>
          1. <ins>Set _F_.[[Brand]] to ~empty~.</ins>
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be DefineField(_F_, _elementRecord_).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be ? Call(_elementRecord_.[[BodyFunction]], _F_).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Return _F_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>
  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>
    <emu-clause id="sec-scripts-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>

      <emu-grammar>ScriptBody : StatementList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if |StatementList| Contains `super` unless the source code containing `super` is eval code that is being processed by a direct eval. Additional early error rules for `super` within direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
          </li>
          <li>
            It is a Syntax Error if |StatementList| Contains |NewTarget| unless the source code containing |NewTarget| is eval code that is being processed by a direct eval. Additional early error rules for |NewTarget| in direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.
          </li>
          <li>
            <ins>It is a Syntax Error if |StatementList| Contains |BrandCheckCall| unless the source code containing |BrandCheckCall| is eval code that is being processed by a direct eval. Additional early error rules for |BrandCheckCall| in direct eval are defined in <emu-xref href="#sec-performeval"></emu-xref>.</ins>
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |StatementList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |StatementList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |StatementList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |StatementList| with argument &laquo; &raquo; is *false* unless the source code containing |ScriptBody| is eval code that is being processed by a direct eval.
          </li>
        </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>
    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>
      <emu-clause id="sec-module-semantics-static-semantics-early-errors">
        <h1>Static Semantics: Early Errors</h1>
        <emu-grammar>ModuleBody : ModuleItemList</emu-grammar>
        <ul>
          <li>
            It is a Syntax Error if the LexicallyDeclaredNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the LexicallyDeclaredNames of |ModuleItemList| also occurs in the VarDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if the ExportedNames of |ModuleItemList| contains any duplicate entries.
          </li>
          <li>
            It is a Syntax Error if any element of the ExportedBindings of |ModuleItemList| does not also occur in either the VarDeclaredNames of |ModuleItemList|, or the LexicallyDeclaredNames of |ModuleItemList|.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains `super`.
          </li>
          <li>
            It is a Syntax Error if |ModuleItemList| Contains |NewTarget|.
          </li>
          <li>
            <ins>It is a Syntax Error if |ModuleItemList| Contains |BrandCheckCall|.</ins>
          </li>
          <li>
            It is a Syntax Error if ContainsDuplicateLabels of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedBreakTarget of |ModuleItemList| with argument &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if ContainsUndefinedContinueTarget of |ModuleItemList| with arguments &laquo; &raquo; and &laquo; &raquo; is *true*.
          </li>
          <li>
            It is a Syntax Error if AllPrivateIdentifiersValid of |ModuleItemList| with argument &laquo; &raquo; is *false*.
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
